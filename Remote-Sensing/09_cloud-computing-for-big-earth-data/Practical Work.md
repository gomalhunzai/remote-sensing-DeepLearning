---
publishable: false
tags: []
date_updated: 2025-07-22
author: Generated by AI
---

# Exercises (remote sensing undergradute) â€“ Cloud Computing for Big Earth Data
> Here are 10 practical exercises to apply the concepts from the chapter "Cloud Computing for Big Earth Data" and prepare for the assessment. They are specifically designed for remote sensing undergradute.

---

> [!question]
> ### Exercise 1: First Steps with Google Earth Engine
> Your task is to write a Google Earth Engine (GEE) script to find and display a recent, low-cloud Landsat 9 image of Dubai, UAE.
>
> 1.  Define a point of interest over Dubai.
> 2.  Access the `==Landsat 9 Collection 2, Tier 1 Surface Reflectance==` Image Collection.
> 3.  Filter the collection by date (e.g., the last 12 months) and by your point of interest.
> 4.  Sort the resulting collection by the `==CLOUD_COVER==` property to find the clearest image.
> 5.  Display the selected image on the map using a `==true-color composite==`.
>
> > [!TIP] Hint
> > Use `ee.ImageCollection('LANDSAT/LC09/C02/T1_L2')`. Remember that GEE methods can be chained together (e.g., `.filterBounds().filterDate().sort()`). The `first()` method is useful for selecting the top image from a sorted collection.

---

> [!question]
> ### Exercise 2: Monitoring Agricultural Health with NDVI
> Generate a time-series chart of the Normalized Difference Vegetation Index (NDVI) for an agricultural region in the Flevopolder, Netherlands, over a full growing season (e.g., March to October of last year).
>
> - Use the `==Sentinel-2 MSI==` dataset.
> - Write a function to calculate NDVI `==(NIR - Red) / (NIR + Red)==` and add it as a new band to each image in the collection.
> - Create a chart that plots the average NDVI value over time for your defined agricultural area.
> - Analyze the resulting chart: When does the peak of the growing season appear to be?
>
> > [!TIP] Hint
> > The `ui.Chart.image.series()` function is perfect for this. You'll need to provide the image collection, a geometry (your region of interest), a reducer (`ee.Reducer.mean()`), and a scale (e.g., 10 meters for Sentinel-2).

---

> [!question]
> ### Exercise 3: Detecting Deforestation with Radar Data
> Identify areas of potential deforestation in the Amazon basin between 2020 and 2022 using `==Sentinel-1 SAR GRD==` data. Due to frequent cloud cover, radar is an excellent tool for this task.
>
> 1.  Create two mosaics: one for the dry season (e.g., June-Sept) of 2020 and one for the same period in 2022. Use the `==median reducer==` to get a clean composite.
> 2.  Focus on the `==VV polarization==`, as it is sensitive to changes in forest structure.
> 3.  Create a difference image (2020 composite - 2022 composite).
> 4.  Display the difference image. Areas with a significant decrease in backscatter (appearing bright in your difference map) may correspond to deforestation.
>
> > [!TIP] Hint
> > Healthy forests typically have high, stable backscatter. When trees are removed, the backscatter value often decreases. Use `.select('VV')` to isolate the desired polarization.

---

> [!question]
> ### Exercise 4: Mapping Surface Water Changes
> Map the change in the surface area of Lake Mead, USA, a reservoir heavily impacted by drought.
>
> - Use Sentinel-2 imagery to create two cloud-free mosaics: one from a "high-water" year (e.g., 2017) and one from a "low-water" year (e.g., 2023).
> - For each mosaic, calculate the `==Modified Normalized Difference Water Index (MNDWI)==` using the Green and SWIR1 bands.
> - Apply a `==threshold==` (e.g., MNDWI > 0) to create a binary water mask for each year.
> - Display the 2023 water mask in blue and the 2017 "lost" water area (2017 mask but not 2023 mask) in red.
>
> > [!TIP] Hint
> > The MNDWI formula is `(Green - SWIR1) / (Green + SWIR1)`. You can use the `.gt()` (greater than) method on the MNDWI image to easily create the binary mask.

---

> [!question]
> ### Exercise 5: Analyzing the Urban Heat Island Effect
> Investigate the Urban Heat Island (UHI) effect in Cairo, Egypt, using Landsat 8 thermal data.
>
> 1.  Select a clear summer image of Cairo.
> 2.  Select the `==thermal band (ST_B10)==` and apply the necessary `==scaling factors==` and offsets provided in the image metadata to convert the digital numbers to `==Land Surface Temperature (LST)==` in Kelvin or Celsius.
> 3.  Create a visualization palette that clearly shows the temperature gradient, with hotter areas in red/yellow and cooler areas in blue/green.
> 4.  Observe the spatial pattern. Do you see a clear UHI effect where the urban core is warmer than the surrounding vegetated and desert areas?
>
> > [!TIP] Hint
> > The formula for LST conversion is available on the USGS Landsat data pages and in the GEE Data Catalog. It's usually `(DN * multiplicative_band) + additive_band`. Don't forget to convert from Kelvin to Celsius if desired (`.subtract(273.15)`).

---

> [!question]
> ### Exercise 6: Assessing Wildfire Burn Severity
> Map the burn severity of a recent major wildfire (e.g., the 2021 Dixie Fire in California) using the `==differenced Normalized Burn Ratio (dNBR)==`.
>
> - Create a pre-fire and a post-fire Sentinel-2 composite.
> - For each composite, calculate the `==Normalized Burn Ratio (NBR)==` using the NIR and SWIR2 bands.
> - Calculate the dNBR: `dNBR = PreFire_NBR - PostFire_NBR`.
> - Classify the dNBR image into severity levels (e.g., Unburned, Low, Moderate, High) based on established thresholds (you can find these in USGS documentation).
> - Display the final classified burn severity map.
>
> > [!TIP] Hint
> > The NBR formula is `(NIR - SWIR2) / (NIR + SWIR2)`. High dNBR values indicate more severe burning. You can use the `where()` method to create the classified map based on the dNBR values.

---

> [!question]
> ### Exercise 7: Building an Interactive GEE App
> Convert your NDVI time-series script from Exercise 2 into a simple `==interactive GEE App==`. The goal is to allow a user to click on any point on the map and instantly generate an NDVI chart for that location.
>
> - Create a `==user interface (UI)==` with a label for instructions.
> - Use `==Map.onClick() ==` to capture the coordinates of a user's click.
> - When the user clicks, your script should:
>     1. Clear any previous charts.
>     2. Generate the NDVI time-series chart for the clicked point.
>     3. Add the new chart to the UI panel.
>
> > [!TIP] Hint
> > Structure your code within a function that is called by `Map.onClick()`. You'll be working with `ui.Panel`, `ui.Label`, and the charting functions you've already used. This exercise is about `==event-driven programming==`.

---

> [!question]
> ### Exercise 8: Big Data Aggregation and Reduction
> Calculate the mean annual precipitation for Brazil in 2022. This exercise tests your ability to perform a large-scale spatial aggregation on a climate dataset.
>
> 1.  Load the `==CHIRPS Pentad==` precipitation dataset for the year 2022.
> 2.  Get a `==feature collection==` of country boundaries and filter it to select only Brazil.
> 3.  Calculate the total precipitation for the year by using a `==sum() reducer==` on the image collection.
> 4.  Calculate the mean precipitation value within the Brazil boundary using `==reduceRegion()==`.
> 5.  Print the final result (a single number representing the mean precipitation in mm) to the console.
>
> > [!TIP] Hint
> > The `reduceRegion()` function is key here. It requires a reducer (`ee.Reducer.mean()`), a geometry (the Brazil polygon), a scale (the native resolution of CHIRPS), and a `maxPixels` value. You may need to set `maxPixels` to a large number like `1e9`.

---

> [!question]
> ### Exercise 9: Land Cover Classification with Machine Learning
> Perform a simple supervised land cover classification for a small, diverse area (e.g., a coastal city like Vancouver, Canada).
>
> 1.  Create at least four `==feature collections==` by drawing polygons on the map for your training data: `Water`, `Urban`, `Vegetation`, and `Bare Soil`.
> 2.  Merge these features into a single collection, adding a property (e.g., `landcover`) to label them (0, 1, 2, 3).
> 3.  Use a Sentinel-2 composite and sample the spectral values from your training polygons.
> 4.  Train a `==Random Forest classifier==` using the training data.
> 5.  Classify the entire image and display the resulting land cover map.
>
> > [!TIP] Hint
> > Use `image.sampleRegions()` to get your training data. The classifier is instantiated with `ee.Classifier.smileRandomForest()` and trained using the `.train()` method. Finally, use `image.classify()` to apply the trained model.

---

> [!question]
> ### Exercise 10: Exporting Analysis Results
> Take the final classified burn severity map you created in Exercise 6 and export it from Google Earth Engine. This is a critical skill for using GEE results in other software (like QGIS or ArcGIS).
>
> - Write a script to `==export the image to your Google Drive==`.
> - Specify the export parameters:
>     - The image to export (your classified dNBR map).
>     - A clear description/file name.
>     - The scale (e.g., 20 meters).
>     - The region (the area of interest you used for the analysis).
> - Run the script and monitor the export status in the `==Tasks tab==`.
> - As an alternative, try exporting the result as a `==GEE Asset==` to your personal assets folder.
>
> > [!TIP] Hint
> > The function you need is `Export.image.toDrive()`. It does not run immediately but creates a task in the 'Tasks' tab on the right side of the Code Editor. You must click 'Run' in the Tasks tab to start the export.